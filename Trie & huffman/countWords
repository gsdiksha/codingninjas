In the Trie class, numWords keeps track of the number of distinct words stored in the trie. Here's how numWords is updated in the add and remove methods:

add Method
When you add a word to the trie:

The public method add(String word) is called.
It calls the private recursive method add(TrieNode root, String word).
The recursive method traverses down the trie, creating new nodes as needed for each character in the word.
When it reaches the end of the word (word.length() == 0), it checks if the node is already marked as terminating (meaning the word already exists in the trie).
If root.isTerminating is true, it returns false, indicating that the word already exists and shouldn't be counted again.
If root.isTerminating is false, it sets it to true and returns true, indicating that a new word has been added.
Back in the public add method, if the private add method returns true, indicating that a new word was successfully added, numWords is incremented.
This way, numWords is increased only when a new word is added to the trie.

remove Method
When you remove a word from the trie:

The public method remove(String word) is called.
It calls the private recursive method remove(TrieNode root, String word).
The recursive method traverses the trie to find the word. When it reaches the end (word.length() == 0), it checks if the node is marked as terminating.
If it is (root.isTerminating is true), it sets it to false, indicating the word is no longer in the trie, and returns true.
If it is not terminating (root.isTerminating is false), it returns false, meaning the word wasn't in the trie to begin with.
Back in the public remove method, if the private remove method returns true, indicating that a word was successfully removed, numWords is decremented.
In this way, numWords accurately reflects the number of distinct words currently stored in the trie.


class TrieNode{
	char data;
	boolean isTerminating;
	TrieNode children[];
	int childCount;

	public TrieNode(char data) {
		this.data = data;
		isTerminating = false;
		children = new TrieNode[26];
		childCount = 0;
	}
}


public class Trie {

	private TrieNode root;
	private int numWords;

	public Trie() {
		root = new TrieNode('\0');
		numWords = 0;
	}
	

	public void remove(String word){
		if(remove(root, word)) {
			numWords--;
		}
	}
	

	private boolean remove(TrieNode root, String word) {
		if(word.length() == 0){
			if(root.isTerminating) {
				root.isTerminating = false;
				return true;
			}
			else {
				return false;
			}
		}
		int childIndex = word.charAt(0) - 'a';
		TrieNode child = root.children[childIndex];
		if(child == null){
			return false;
		}
		boolean ans = remove(child, word.substring(1));
		// We can remove child node only if it is non terminating and its number of children are 0	

		if(!child.isTerminating && child.childCount == 0){
			root.children[childIndex] = null;
			child = null;
			root.childCount--;
		}
		return ans;
	}

	private boolean add(TrieNode root, String word){
		if(word.length() == 0){
			if(root.isTerminating) {   //If root.isTerminating is true, it returns false, indicating that the word already exists and shouldn't be counted again.
				return false;
			}
			else {                             //If root.isTerminating is false, it sets it to true and returns true, indicating that a new word has been added.
				root.isTerminating = true;
				return true;
			}
		}		
		int childIndex = word.charAt(0) - 'a';
		TrieNode child = root.children[childIndex];
		if(child == null){
			child = new TrieNode(word.charAt(0));
			root.children[childIndex] = child;
			root.childCount++;
		}
		return add(child, word.substring(1));
	}

	public void add(String word){
		if(add(root, word)) {
			numWords++;
		}
	}
	
	public int countWords() {
    return numWords;
}

// private int countWords(TrieNode root) {
//     int count = 0;

//     // If the current node is a terminating node, increase the count
//     if (root.isTerminating) {
//         count++;
//     }

//     // Recursively count the words for all children nodes
//     for (int i = 0; i < 26; i++) {
//         TrieNode child = root.children[i];
//         if (child != null) {
//             count += countWords(child);
//         }
//     }

//     return count;
// }

	
}
